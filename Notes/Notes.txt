//
//  Notes.txt
//  GHFollowers
//
//  Created by Janvi Arora on 09/08/24.
//

=================================================================================

NOTE: Some images are added in assets wrt the below notes.

=================================================================================

 Q: Why Apple split up AppDelegate & SceneDelegate?

 Answer:
 SceneDelegate: Introduced in iOS 13.0

 It allows for multi-window operations. Refer to the screenshots attached in assest
 folder. It represents two instances of same app, i.e. two scenes of same app being shown
 at once.

 Before iOS 13.0, we could have 2 instances side by side but they should be of
 different apps, but now we can have instances of same apps at once (side by side), & the
 SceneDelegate is what that allows this.

 Earlier our app used to have a window, but now it has scenes, which could be multiple.
 So, our app could have one AppDelegate, but multiple scenes. If we'll have 2 scenes up,
 then each scene will have their own sceneWillEnterForeground, sceneDidEnterBackground etc
 functions, to refer which scene was it.

 So, this means you are allowed to have multiple scenes of your app at once on iPad.

 This is called a multi-window paradigm.

 var window: UIWindow? -
 This used to be in AppDelegate earlier, but now it's in SceneDelegate & each scene has
 its own UIWindow. This means that the SceneDelegate is responsible for configuring and
 managing the UI for a particular scene, while the AppDelegate still handles global app
 lifecycle events like app launch or termination. So, the window property is now in
 SceneDelegate because iOS apps can manage multiple scenes (windows) simultaneously.

---------------------------------------------------------------------------------

 A delegate just sits back and listens. & once it is listening on something (e.g. a vc), it's going to say like - "when this action happens, I'll act on it."

 Example:
 In our case, action is tapping the 'Go' button on keyboard.
 Our delegate will wait for that button to get clicked, and then the vc will take an action

---------------------------------------------------------------------------------

 A guard statement is like a 'Line in the sand', which means a point beyond which code will not be executed.

---------------------------------------------------------------------------------

For closures that have a very short lifetime, like those in UIView.animate or DispatchQueue.async, the risk of creating a strong reference cycle is minimal. The system itself ensures that the closure doesn't outlive the context where it's executed.

---------------------------------------------------------------------------------

In termial, we can write below line to get the response of any URL:
'curl https://someURL'

---------------------------------------------------------------------------------

URLSession.shared.dataTask(with: url) { data, response, error in

}.resume()

Here, error represents that network call didn't even take place, maybe due to poor internet connection or something.

If there will be 404 or some other error, then it indicates a server error. This will come in response.

---------------------------------------------------------------------------------

Associated Values: You declare the type after each case. Each case can have a different type.

enum Barcode {
    case upc(Int, Int, Int, Int)
    case qrCode(String)
}

Usage:

var productBarCode: Barcode
productBarCode = .upc(10, 20, 5516, 2)
productBarCode = .qrCode("abcdefg")

---------------------------------------------------------------------------------

Raw Values: These are pre-populated values when you first define the enum in your code. All the cases conform to one type.

enum AsciiControlCharacters: Character {
    case tab = "\t"
    case lineBreak = "\n"
}

Usage:

var asciiChar: AsciiControlCharacters
asciiChar = .tab

---------------------------------------------------------------------------------

Diffable Data Source: Best for dynamic, complex data with frequent updates, multiple sections, and where automatic animations are desired.

Simple Data Source: Best for static or minimally changing data, when you need manual control, or in legacy/older projects.

---------------------------------------------------------------------------------

UICollectionViewDiffableDataSource will take only Hashables in it

NOTE: Enums are by default Hashable

---------------------------------------------------------------------------------

Pagination:

1. Detect when we are at the bottom of scroll view.
2. Check if they have more followers
3. Bring in next set of followers

NOTE: UICollectionViewDelegate conforms to UIScrollViewDelegate, so we don't have to separately conform to UIScrollViewDelegate, anytime we use collection view or table view.

---------------------------------------------------------------------------------

NOTE: Avoid doing pre-mature optimization.

---------------------------------------------------------------------------------
